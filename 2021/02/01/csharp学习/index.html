<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我是良民的博客"><meta name="baidu-site-verification"><title>csharp学习 | 我是良民</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="我是良民" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/prettify/doxy.css"><script type="text/javascript" src="/js/ready.js" async></script><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">我是良民</a></h1></div><p class="m-desc">心之所向，无惧无悔,<br>愿求仁得仁，复无怨怼！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li><span class="dot">●</span><a href="/about/">关于</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">csharp学习</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2021/02/01/csharp%E5%AD%A6%E4%B9%A0/">2021-02-01</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><h2 id="vs设置"><a href="#vs设置" class="headerlink" title="vs设置"></a>vs设置</h2><p>vs中F6键：生成语法错误，可以定位到错误位置。</p>
<p>设置当前启动项目，点击解决资源管理器，右击，属性，启动项目设置为当前选定内容。</p>
<p>多行注释：ctrl + k+c,取消多行注释：ctrl +k +u</p>
<p>输出快捷键：cw+两次tab键 ，foreach快捷键，foreach +两次tab键</p>
<p>构造器快捷键：ctor+两次tab键</p>
<p>激活key：BWG7X-J98B3-W34RT-33B3R-JVYW9</p>
<p>对于一些控件的属性设置在，视图选项卡的属性可以调出</p>
<p>鼠标放在某个类上直接按住F1键，会自动定位到对该类的解释文档。</p>
<p>直接删除某行ctrl+L</p>
<p>assembly ：类库</p>
<p>Ctrl+.快捷键或者ctrl+j，是智能识别快捷键，相当于eclipse中的alt+/,java中完全使用接口interface代替了委托</p>
<p>自动实现接口中的所有方法：alt+insert</p>
<p>替换快捷键：ctrl+r</p>
<h2 id="窗口设置"><a href="#窗口设置" class="headerlink" title="窗口设置"></a>窗口设置</h2><p>窗口标题更改：属性：外观，text修改即可</p>
<p>修改窗口左上角小图标：窗口样式，Icon，选择图片进行设置即可，最大不超过72x72</p>
<p>窗体出现的位置设置：布局，startposition。</p>
<p>固定窗口的大小，不允许改变：布局，AntoSize= false</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>方法重载区别点：1.返回类型，2.传参类型，3.传参数目</p>
<p>判断类，数据类型等，type a = typeof(int);</p>
<p>类的继承：使用‘：’进行继承，而java中是使用extends关键词进行继承，代码如下</p>
<p>class Person : Student{</p>
<p>}</p>
<p>Sizeof方法只能计算基本数据类型的大小。例如sizeof(int)。</p>
<p>对一个变量求相反数：- -x这是错误的，-(-x)这是正确的。</p>
<p>While语句与for语句的使用情况，当知道执行循环次数的时候使用for循环，其他情况的时候都是使用while语句。Foreach语句是迭代器，只能用于迭代集合中的元素或者数组。</p>
<p>readonly关键字：表示该变量只能被赋予一次值 public readonly int ID;</p>
<p>main方法中string[] args 说明声明的是长度为0的字符串数组。</p>
<p>栈：存储局部变量            </p>
<p>堆：new出来的对象</p>
<p> 默认赋值：整形：0，浮点型0.0，布尔型：false，字符型：\u0000;</p>
<p>静态：非静态成员方法既可以访问静态，也可以访问非静态，静态成员方法只可以访问静态</p>
<p>Public 不同项目中可以使用  internal(或者不写)限制在统一个项目中，被sealed修饰的类不能被继承，子类访问级别不能超过父类</p>
<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><p>namespace ：use system实际上就是使用了名称空间。就是将类放在名称空间里面，例如Console.WriteLine这个方法，使用的console这个类就是system这个名称空间里面的类，如果没有use system这个调用，需要使用system.console.writeline这个方法使用，这是比较麻烦的，所以程序开头就直接引用system这个名称空间。如何寻找命名空间：把一个类名写出来后，点击这个类，左下角会自动出现所属命名空间，引用即可。</p>
<p>属性 property 方法：method ，事件event</p>
<p>命名：类或者接口:大驼峰</p>
<p>​            变量和方法：小驼峰</p>
<p>​            常量：全部大写</p>
<h3 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h3><p>如果类中定义了构造器，那么系统就不会提供默认无参构造器，否则系统提供默认无参构造器。构造器的作用：该类在被创建对象时，就会自动执行构造器的内容，不需要再后续代码中再重新指定，相当于所有来自于该类的对象的共有属性。</p>
<p>构造方法：为对象的属性进行赋值，这样在创建对象时，直接在创建对象的形参中传入参数即可，不必每次都使用set方法，例如new Student(‘张三’,23);，为了使构造方法多样性，可以重载构造方法。若自己写出有参构造方法，那么系统不会提供无参构造，无参构造需要自己写才能调用。构造方法用来初始化属性和set，get方法作用差不多，可以后续对属性进行修改，推荐使用get，set方法，因为更加灵活。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><pre><code> //判断Form类属于什么类型
            Type myForm = typeof(Form);
            Console.WriteLine(myForm);
            //Console.WriteLine(Form);这是错误的，java可以直接这样输出一个类的信息，但是c#不可以</code></pre><pre><code>var的变量类型， static void Main(string[] args)
    {
        Console.WriteLine();
        var a = 3;
        var b = 3L;
        var c = &quot;hello world&quot;;

        Console.Write(a.GetType().Name);
        Console.Write(a.GetType().Name);
        Console.WriteLine(c.GetType().Name);

    }结果为  Int32
            Int32
            String，说明var类型是个自动识别变量类型的变量。</code></pre><p>数据类型和表示范围：int ：占4个字节，long :占8个字节，byte，一个字节，short：两个字节，float :4个字节，double:8个字节，char：2个字节，bool，1/8个字节，<font color="red">整数默认是int，小数默认是double</font>&gt;，所以long x=8888888888L错误，float x = 12.3错误，应为float x = 12.3f。</p>
<p><img src="/2021/02/01/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210202203407102.png" alt="image-20210202203407102"></p>
<p>c#五大数据类型： 1.类类型class</p>
<p>​                                2.接口interface</p>
<p>​                                3.结构体类型struct</p>
<p>​                                4.枚举类型（enum）：即给类的某个属性设置为某几个固定值，可以任意选择。（一对多）</p>
<p>​                                5.委托类型deledates</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承：  静态方法不能被继承，</p>
<p>子类只能继承父类的非私有化成员，</p>
<p>子类不能继承父类的构造方法，若调用，需使用base关键字</p>
<p>若父类和子类中有相同的成员变量，根据就近原则优先使用子类的，子类没有的话会去调用父类。方法同样优先调用子类方法   </p>
<p>继承：子类 is 父类，is关键字就是判断符</p>
<p>父类的构造器不可以被子类继承，因为每个类的构造器名必须与它自己的类名相同，所以当父类使用有参构造的时候，子类中的空参构造默认调用（是调用不是继承）父类的空参构造(即类似java中子类构造器中默认会有super())，而父类不提供空参构造，所以导致报错，解决方法:在子类中创建有参构造调用父类的有参构造</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Son s = new Son(5000);

​      Console.WriteLine(s.money);

​    }

  }



  class Father

  {

​    public int money;

​    public Father(int money)

​    {

​      this.money = money;

​    }

  }

  class Son :Father{

​    public Son(int money):base(money)//手动让子类的有参构造调用父类的有参构造

​    {

​    }

  }</code></pre><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写：子类继承了父类中的方法，同时将父类中的方法进行了改造，优先使用子类的方法，重写的返回值是相同的或者是子父类之间的关系，参数列表必须一样</p>
<p>注意c#中的重写与java中的重写不一样，c#中父类被重写的方法需加上virtual关键字，子类中被重写的方法需加上override关键字，如果不加上这两个关键字，那么意味着父类和子类各有自己的introduce方法，如果此时使用多态进行父类引用子类对象时，就不会出现编译看父类运行看子类，多态也就没有意义。</p>
<pre><code>public virtual void introduce() {

​      Console.WriteLine(&quot;我是父亲类&quot;);

​    }



public override void introduce() {

​      Console.WriteLine(&quot;我是儿子类&quot;);

​    }



Public override void introduce(){

​        Console.writeLine(“我是孙子类”);

}</code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态：（好处提高代码的复用性）例如</p>
<p>前提1，具有继承关系2，有方法重写3.有父类引用指向子类对象</p>
<p>​                对于成员变量，编译看父类，运行看父类</p>
<p>​                对于成员方法，编译看父类，运行看子类</p>
<p>​                对于静态方法，编译看父类，运行看父类</p>
<p>以上是父类和子类共有相同的方法，若子类中的方法父类没有，那么就需要进行向下转型或者向上转型：</p>
<p>向上转型，父类引用指向子类对象，</p>
<p>向下转型，使用括号进行父类转化为子类，注意，必须先完成向上转型才能接着完成向下转型。即Father father = new Son();   Son son = (Son)father。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类abstract</p>
<p>中的抽象方法强制子类必须去重写该抽象方法。抽象类的作用：1.给其他类作父类2.作为多态实现父类引用子类对象。</p>
<p>接口：interface，接口仍然使用:去实现，java中是implements是实现。若子类不想要完全去实现所有的接口中的功能，例如Run方法，就使用abstract public void Run();不去重写该方法，继续作为抽象方法即可</p>
<p>所有方法都为抽象方法的类作为接口</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>是定义在类里面，方法的外面，然后在方法里面使用    例如</p>
<pre><code>enum level{

​        low,

​        mid,

​        high,

​        super

​      };</code></pre><p>权限：public：公用</p>
<p>​            protected</p>
<p>​            private ：私用,只允许类的内部方法互相调用。</p>
<p>​            无定义:</p>
<p>+无穷大:double.PositiveInfinity</p>
<p>-无穷大：double.negativeInfinity</p>
<h3 id="is和as"><a href="#is和as" class="headerlink" title="is和as"></a>is和as</h3><p>的使用方法：is用来判断该对象是否是某个类的对象，或者是某个类的子类的对象，返回的是一个bool型，而as原理与is相似，返回的是个对象或者null</p>
<pre><code>static void Main(string[] args)
        {
            teacher t = new teacher();
            bool flag = t is teacher;//判断是否是t是否是teacher的对象，true
            Console.WriteLine(flag);
            bool flag2 = t is Person;判断是否是person的对象，因为teacher是person的子类，所以结果为true
            Console.WriteLine(flag2);
    }
}
class Person {
    public void think() { 

    }
}

class teacher : Person {
    public void study() { 

    }
}</code></pre><p>与java相似，c#创建对象的时候也有两种方式，第二种方式创建的对象只能使用一次，第一种方式创建的对象可以无限使用，其中中括号里面的内容表示对Form这个类中的属性进行更改。代码如下。</p>
<pre><code>static void Main(string[] args)

​    {

​      Form fm = new Form();

​      fm.Text = &quot;这是我的第一个程序&quot;;

​      fm.ShowDialog();



​      new Form() { Text = &quot;这是我的第二个程序&quot;}.ShowDialog();

​    }</code></pre><h3 id="匿名对象："><a href="#匿名对象：" class="headerlink" title="匿名对象："></a>匿名对象：</h3><p>创建对象的另一种方式（java没有），该类没有名称，所以使用var作为接受类型，然后在{}中写入属性内容。（注意{}中不能添加方法只能添加属性）</p>
<p>var person = new { name = “张三”, age = 64 };</p>
<p>​      Console.WriteLine(person.name);</p>
<p>​      Console.WriteLine(person.age);</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>1)将string类型转换为int类型,使用Convert类中的toInt32()方法。</p>
<pre><code>string str1 = “10”;

​      string str2 = “20”;

​      int it1 = Convert.ToInt32(str1);

​      int it2 = Convert.ToInt32(str2);

​      Console.WriteLine(it1+it2);

​    2)显视类型转换，例如将Stone这个类转换为Monkey类，（这个在java中是没有办法实现的。）代码如下

static void Main(string[] args)

​    { 

​      Stone stone1 = new Stone();

​      stone1.age = 5000;

​      Monkey wukong = (Monkey)stone1;

​      Console.WriteLine(wukong.age);

​    }

  }

  class Stone {

​    public int age;

​        //注意是在被转换的代码下面写如下代码

​    public static explicit operator Monkey(Stone st){

​      Monkey m = new Monkey();

​      m.age = stone.age/500;//石头五百年相当于猴子一年

​      return m;

​    }

  }

  class Monkey {

​    public int age;

 }</code></pre><h3 id="使用get-set-方法的意义："><a href="#使用get-set-方法的意义：" class="headerlink" title="使用get(),set()方法的意义："></a>使用get(),set()方法的意义：</h3><p>为了让用户在创建对象并且为属性赋值的时候进行合法赋值（例如年龄0&lt;age&lt;100），通常将属性值设置为private权限（不让用户在没有筛选的条件下使用属性）,然后提供 set，get方法进行赋值和取值，在set，get方法中进行合理值的过滤和筛选。代码如下（注意，这是java中的代码）</p>
<pre><code> static void Main(string[] args)

​    {

​      Student st1 = new Student();

​      st1.setAge(50);

​      Console.WriteLine(st1.getName()+st1.getAge());



​      Student st2 = new Student();

​      st2.setAge(100);

​      Console.WriteLine(st2.getName()+st2.getAge());

​    }

  }

  class Student {

​    private int age;

​    private string name;



​    public void setAge(int age) {

​      if (0 &lt; age &amp;&amp; age &lt; 100)

​      {

​        this.age = age;

​      }

​      else {

​        Console.WriteLine(&quot;请输入年龄在0-100之间&quot;);

​      }

​    }

​    public int getAge() {

​      return this.age;

​    }



​    public void setName(string name) {

​      this.name = name;

​    }

​    public string getName() {

​      return this.name;

​    }

  }

}</code></pre><p>我们可以看到java中的代码在访问属性时比较麻烦，为了想要用st1.age这种与public访问属性方式，c#创造了另一种写法，但是逻辑思想与java是一样的，代码如下</p>
<p>（简便书写方法，快捷键，输入propfull按两下tab键，输入对应的参数即可）</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Student st = new Student();

​      st.Age = 20;                    //在这里可以直接使用这种方式访问（注意使用Age而不是age，相当于为age又起了一个变量名Age），下面的set代码块中限制了了用户年龄范围。

​      Console.WriteLine(st.Age);    

​    }

  }

  class Student {

​    private int age;                    //这个必须写，而且是private

​        public int Age {                    //这里与java不同，c#可以在创建属性的同时直接使用与get，set方法类似的代码块进行年龄范围设置，同时这里是public，相当于为age起了另一个变量名Age

​      set {

​        if (value &gt; 0 &amp;&amp; value &lt; 100)         &lt;font color = &#39;red&#39;&gt;//注意value此时写在get，set代码块中，value此时是个关键字（只在get，set方法中value是个关键词，在其他代码块中value不是 关键字，可以随便使用），因为此代码块中get和set不是方法所以无法传参，所以微软规定value就是这个形参，在上面st.Age = 20时，实际上value的值就等于20，若value写在string类型的代码块中，value就是个string类型的。&lt;/font&gt;

​        {

​          this.age = value;

​        }

​        else {

​          Console.WriteLine(&quot;年龄区间输入错误&quot;);

​        }

​      }

​      get {

​        return this.age;

​      }

​    }

  }

还有一种写法

Public int Age{get;set;}//这种写法是定义了一种变量Age，但是get和set中没有对Age进行限制，与public int age;</code></pre><h3 id="ref关键字："><a href="#ref关键字：" class="headerlink" title="ref关键字："></a>ref关键字：</h3><p>类似于指针，如下method方法中形参为ref类型，实参y传入后，x与y指向同一个内存地址，所以x直接操作的是y对应的地址，所以最终输出结果为101，而不是100</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      int y = 100;

​      method(ref y);

​      Console.WriteLine(y);

​    }

​    static void method(ref int x ) {

​      x = x + 1;  

​    }

  }</code></pre><h3 id="具名参数："><a href="#具名参数：" class="headerlink" title="具名参数："></a>具名参数：</h3><p>实际上就是传参的另一种使用方法，（c#独有，意义不大）在调用method方法时，实参使用name:”张三”，age:23这种方式的好处一是可读性比较强，二是传参时可以不必按照method的形参的类型顺序进行赋值，即method(age:23,name:”张三”)这种传参方式也可以。</p>
<pre><code>static void Main(string[] args)
{

  method2(name: &quot;张三&quot;,age:23);

}    

}

static void method2(String name, int age) {

  Console.WriteLine(name+age);

}</code></pre><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托：  表示具有特定参数列表和返回类型的引用，好处：将方法作为参数传递出去，将方法封装成一个对象进行传递，可以完成对该方法的使用，避免重写该方法。委托是一种类</p>
<p>delegate（可以无返回值，可以指定返回值类型）， </p>
<p>Action(无返回值的泛型)，Action&lt;int,string&gt;表示传入int，string无返回值的委托</p>
<p>Func（有返回值的泛型委托），Func&lt;string,int&gt;表示传入参数为string，返回值为int的委托</p>
<p>predicate（返回值是布尔类型的泛型委托）predicate<int>表示传入参数为int，返回bool的委托。</int></p>
<p>自定义委托：但是上面的四种委托已经足够了，自己通过代码体验就好，但是注意，自定义委托是一种类，需声明在其他类的外面，如果声明在其他类的里面，则属于嵌套类，则在使用时需要使用 当前所在类的类名.del1  cal1 = new  del1(c1.add);进行调用</p>
<p>代码如下</p>
<pre><code>namespace test5

{

  public delegate int del1(int x,int y);//自定义的委托，与下面的Action，Func具有同样的作用,自定义委托写在其他类的外面。

  class Program

  {

​    static void Main(string[] args)

​    {

​      Calculator cl = new Calculator();

​      Action action = new Action(cl.Report);

​      cl.Report();//传统方法调用report方法

​      action.Invoke();//使用委托调用report方法

​      action();//使用委托调用另一种写法



​      Func&lt;int,int,int&gt; func1 = new Func&lt;int,int,int&gt;(cl.Add);//两个参数类型，一个返回类型

​      Func&lt;int, int, int&gt; func2 = new Func&lt;int, int, int&gt;(cl.sub);

​      Console.WriteLine(func1(2,3));

​      Console.WriteLine(func2(5,5));



​      //使用自定义委托

​      del1 cal1 = new del1(cl.Add);

​      Console.WriteLine(cal1(5, 6)); 

​    }

  }



  class Calculator {

​    public void Report() {

​      Console.WriteLine(&quot;I have three methods&quot;);

​    }

​    public int Add(int a,int b) {

​      int result = a + b;

​      return result;

​    }

​    public int sub(int a, int b) {

​      int result = a - b;

​      return result;

​    }

  }

}</code></pre><p>多播委托：一个委托内部封装着多个方法，顺序是按照添加的顺序执行，如果想要进行多线程争抢执行顺序，需使用BeginInvoke();  方法即action1.BeginInvoke();  action2.BeginInvoke(); action3.BeginInvoke();</p>
<p>代码如下</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Student st = new Student();

​      Teacher t = new Teacher();

​      Worker w = new Worker();



​      Action action1 = new Action(st.doHomeWork);

​      Action action2 = new Action(t.Teach);

​      Action action3 = new Action(w.work);

​      //多播委托

​      action1 += action2;//将action2添加到action1中

​      action1 += action3;//将action3添加到action1中

​      action1.Invoke();//执行顺序，按照添加顺序开始执行ation1，action2，action3

​    }

  }

  class Student {

​    public void doHomeWork() {

​      Console.WriteLine(&quot;我是学生&quot;);

​    }

  }

  class Teacher {

​    public void Teach() {

​      Console.WriteLine(&quot;我是老师&quot;);

​    }

  }

  class Worker {

​    public void work() {

​      Console.WriteLine(&quot;我是工人&quot;);

​    }

}</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件的五个成员：1.事件的拥有者（event source）        2.事件成员（event）        3.事件的响应者(event subcriber)            4.事件处理器(响应者中的处理方法)            5.事件订阅：事件 += 事件处理器（本质上是以委托为基础的约定）</p>
<p>写事件之前先把以上五个关于事件的东西写出来</p>
<p>事件拥有者和事件的响应者共有四种组合方式，推荐第四种</p>
<p>如下第一种组合方式和对应代码，</p>
<p><img src="/2021/02/01/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214254615.png" alt="image-20210219214254615"></p>
<pre><code>
class Program
    {
        static void Main(string[] args)
        {
            Timer time = new Timer();//事件的拥有者，即小闪电符号的就是事件，小扳手是属性，小方块是方法
​           time.Interval = 1000;
            Boy boy = new Boy();//事件的响应者
            Girl girl = new Girl();
            time.Elapsed += boy.Action;//左边是事件，右侧是事件处理器（即Action方法），中间+=就是事件的订阅
            time.Elapsed += girl.Acton;
            time.Start();
            Console.ReadLine();
  }
}
class Boy {
    internal void Action(object sender, ElapsedEventArgs e)
    {
        Console.WriteLine(&quot;jump&quot;);
    }
}
class Girl {

    internal void Acton(object sender, ElapsedEventArgs e)
    {
        Console.WriteLine(&quot;sing&quot;);
    }
}</code></pre><p>第二种组合方式，事件的拥有者和事件的响应者是两个不同的对象。代码重新看视频</p>
<p><img src="/2021/02/01/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214539229.png" alt="image-20210219214539229"></p>
<p>第三种组合方式，事件的拥有者和事件的响应者是同一个对象</p>
<p><img src="/2021/02/01/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214620011.png" alt="image-20210219214620011"></p>
<p>第四种组合方式：事件的拥有者是事件响应者的字段成员</p>
<pre><code> class Program
    {
        static void Main(string[] args)
        {
            MyForm mf = new MyForm();
            mf.ShowDialog();
        }
    }
    class MyForm : Form {//myFrom 作为事件的响应者
        private Button button;//事件拥有者
        private TextBox tb;
        public MyForm()
        {
            button = new Button();
            tb = new TextBox();
            this.Controls.Add(button);
            this.Controls.Add(tb);
            this.button.Click += this.action;//事件+=事件处理=》事件订阅
            this.button.Text = &quot;say hello&quot;;
            this.button.Top = 50;
        }
        private void action(object sender, EventArgs e)
    {    
        this.tb.Text = &quot;helloWorld&quot;;
    }
}</code></pre><p>针对事件订阅时，即左侧为事件，右侧为事件处理，整个过程为订阅，则订阅过程共有三种写法，如下</p>
<pre><code>public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            //this.button3.Click += this.button_Click;//这是第一种写法
            //第二种写法，使用了EventHandler进行了委托
            this.button3.Click += new EventHandler(this.button_Click);
            //第三种写法，lamdam表达式
            this.button3.Click += (sender, e) =&gt; { this.textBox1.Text = &quot;我是button3&quot;; };
        }

        private void button_Click(object sender, EventArgs e)
        {//一个事件处理器可以挂接多个不同的事件
            if (sender == button1) {
                this.textBox1.Text = &quot;我是button1&quot;;

            }
            if (sender == button2) {
                this.textBox1.Text = &quot;我是button2&quot;;
            }


        }
    }</code></pre><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型：为什么用泛型？防止类膨胀和成员膨胀。</p>
<p>使用泛型的情况，类太多和成员变量太多或者不确定变量类型属于什么类型。方法泛型：当形参接受不同的数据类型，但是方法中对形参处理的逻辑一样就考虑使用方法泛型。只要写变量类型的时候就考虑用泛型 。</p>
<p>类膨胀如下，苹果对应一个盒子类和一个产品类，书对应一个盒子类一个产品类，那么1000中对应2000个类，这就是成员膨胀</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Apple apple = new Apple() { color = &quot;red&quot; };

​      AppleBox box = new AppleBox() { cargo = apple };

​      Console.WriteLine(box.cargo.color);



​      Book bk = new Book() { bookName = &quot;new book&quot; };

​      BookBox bb = new BookBox() { book = bk };

​      Console.WriteLine(bb.book.bookName);

​    }

  }

  class Apple {

​    public string  color { get; set; }



  }

  class AppleBox {

​    public Apple cargo { get; set; }

  }

  class Book {

​    public String bookName { get; set; }

  }

  class BookBox {

​    public Book book { get; set; }

  }</code></pre><p>成员膨胀：如下，在创建box1对象时，只用到了Apple这个属性，创建box2这个对象时只用到了Book这个属性，如果1000中商品，在Box类中就有1000个类属性，创建一个对象时，其他属性就多余，这就属于成员膨胀</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Apple apple = new Apple() { color = &quot;red&quot; };

​      Book book = new Book(){ bookName = &quot;new book&quot;};

​      Box box1 = new Box() { cargo = apple };

​      Box box2 = new Box() { bk = book };

​      Console.WriteLine(box1.cargo.color);

​      Console.WriteLine(box2.bk.bookName);

​      

​    }

  }

  class Apple {

​    public string  color { get; set; }



  }

  class Box {

​    public Apple cargo { get; set; }

​    public Book bk { get; set; }

  }

  class Book {

​    public String bookName { get; set; }

  }</code></pre><p>解决方法：使用泛型，如下，当Box后面使用<Tcargo>说明，当创建Box对象时&lt;&gt;里面是什么类型，那么该类型会自动替换Box类中的Tcargo作为一种类型，box1中的cargo类型就是Apple类型，box2中的cargo类型就是Book类型。</Tcargo></p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Apple apple = new Apple() { color = &quot;red&quot; };

​      Book book = new Book(){ bookName = &quot;new book&quot;};

​      Box&lt;Apple&gt; box1 = new Box&lt;Apple&gt;() { cargo = apple };

​      Box&lt;Book&gt; box2 = new Box&lt;Book&gt;() { cargo = book };

​      Console.WriteLine(box1.cargo.color);

​      Console.WriteLine(box2.cargo.bookName);

​    }

  }

  class Apple {

​    public string  color { get; set; }

  }

  class Box&lt;Tcargo&gt; {

​    public Tcargo cargo { get; set; }  

  }

  class Book {

​    public String bookName { get; set; }

  }</code></pre><h3 id="Partial类"><a href="#Partial类" class="headerlink" title="Partial类"></a>Partial类</h3><h3 id="Lambda表达式："><a href="#Lambda表达式：" class="headerlink" title="Lambda表达式："></a>Lambda表达式：</h3><p>使用情况：在程序中只调用一次，可以使用lambda表达式，不用再创建类和方法进行调用，例如Func&lt;int,int,int&gt; func = new Func&lt;int,int,int&gt;({inta,int b}=&gt;{return a+b;});进行加法运算,简化后为Func&lt;int,int,int&gt; func = (a,b)=&gt;{return a+b;};</p>
<p>例子</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      DoSomeCalc((a,b)=&gt;{return a*b;},100,200);

​    }

​    static void DoSomeCalc&lt;T&gt;(Func&lt;T, T, T&gt; func, T x, T y) {

​      T res = func(x, y);

​      Console.WriteLine(res);

​    }

  }</code></pre></div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">我是良民</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2021/02/01/csharp%E5%AD%A6%E4%B9%A0/">http://yoursite.com/2021/02/01/csharp学习/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="http://yoursite.com">我是良民的博客</a>！</span></div></blockquote></div></article><div class="p-info box"></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#vs设置"><span class="toc-number">1.</span> <span class="toc-text">vs设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#窗口设置"><span class="toc-number">2.</span> <span class="toc-text">窗口设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内容"><span class="toc-number">3.</span> <span class="toc-text">内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意点："><span class="toc-number">3.1.</span> <span class="toc-text">注意点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#名称空间"><span class="toc-number">3.2.</span> <span class="toc-text">名称空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造器："><span class="toc-number">3.3.</span> <span class="toc-text">构造器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">3.4.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">3.5.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写"><span class="toc-number">3.6.</span> <span class="toc-text">重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-number">3.7.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">3.8.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举"><span class="toc-number">3.9.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is和as"><span class="toc-number">3.10.</span> <span class="toc-text">is和as</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名对象："><span class="toc-number">3.11.</span> <span class="toc-text">匿名对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型转换"><span class="toc-number">3.12.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用get-set-方法的意义："><span class="toc-number">3.13.</span> <span class="toc-text">使用get(),set()方法的意义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref关键字："><span class="toc-number">3.14.</span> <span class="toc-text">ref关键字：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#具名参数："><span class="toc-number">3.15.</span> <span class="toc-text">具名参数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#委托"><span class="toc-number">3.16.</span> <span class="toc-text">委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件"><span class="toc-number">3.17.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型"><span class="toc-number">3.18.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial类"><span class="toc-number">3.19.</span> <span class="toc-text">Partial类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda表达式："><span class="toc-number">3.20.</span> <span class="toc-text">Lambda表达式：</span></a></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2021/02/28/winform%E5%AD%A6%E4%B9%A0/">&lt; winform学习</a><a class="next" href="/2020/04/08/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">安全基础学习 &gt;</a></div><div id="valine-comment"><style type="text/css">.night .v[data-class=v] a { color: #0F9FB4 !important; }
.night .v[data-class=v] a:hover { color: #216C73 !important; }
.night .v[data-class=v] li { list-style: inherit; }
.night .v[data-class=v] .vwrap { border: 1px solid #223441; border-radius: 0; }
.night .v[data-class=v] .vwrap:hover { box-shadow: 0 0 6px 1px #223441; }
.night .v[data-class=v] .vbtn { border-radius: 0; background: none; }
.night .v[data-class=v] .vlist .vcard .vh { border-bottom-color: #293D4E; }
.night .v[data-class=v] .vwrap .vheader .vinput { border-bottom-color: #223441; }
.night .v[data-class=v] .vwrap .vheader .vinput:focus { border-bottom-color: #339EB4; }
.night .v[data-class=v] code, .night .v[data-class=v] pre,.night .v[data-class=v] .vlist .vcard .vhead .vsys { background: #203240 !important; }
.night .v[data-class=v] code, .night .v[data-class=v] pre { color: #F0F0F0; font-size: 95%; }
.v[data-class=v] .vcards .vcard .vh {border-bottom-color: #223441; }
.night .v[data-class=v] .vcards .vcard .vcontent.expand:before {background: linear-gradient(180deg,rgba(38,57,73,.4),rgba(38,57,73,.9));}
.night .v[data-class=v] .vcards .vcard .vcontent.expand:after {background: rgba(38,57,73,.9)}
</style><div id="vcomment"></div><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'',
  appKey:'',
  lang: 'zh-cn',
  placeholder:'ヾﾉ≧∀≦)o Come on, say something...',
  avatar:'identicon',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></section><footer><p>Copyright © 2016 - 2021 <a href="/." rel="nofollow">我是良民</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/plugins/prettify/prettify.js"></script><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"></body></html>